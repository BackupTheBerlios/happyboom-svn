Introduction
============

Hachoir is a library written in Python to access binary streams using
nice API. It aims to be easy to use (hide complex mechanisms) and only read
or compute data when it's really needed.

Examples of Hachoir use: extract some informations from a file (size of an
image, author of a music, comment of an archive, etc.), edit some fields of
a file, convert a format to another one.

Write your own format FieldSet class
====================================

Input stream
------------

For different reasons (eg. addresses with bit granularity), Hachoir uses it's
own stream classes. The most interesting class is FileStream. It's constructor
need a file and a filename (optionnal, can be None).

Here is a small example to create a stream:

>>> from stream.file import FileStream
>>> from StringIO import StringIO
>>> stream = FileStream(StringIO("\x03abc"), None)

StringIO is a class which works like a file object but using a string as input
data. Most interesting methods are:

>>> stream.getSize()       # get size in bits
32
>>> stream.getBits(0, 8)   # get 8 bits at address 0
3
>>> stream.getBytes(8, 3)  # get 3 bytes at address 8
'abc'

Support your own format using FieldSet
--------------------------------------

In the Hachoir, everything is stored in a field. The parent of all classes is
the class Field, but it can't be used directly. They are four different types
of fields:
 * Bits: number with a size in bits ;
 * Integer: number with a size in bytes ;
 * String: string of characters with a size in bytes ;
 * FieldSet: a ordered list of fields (contains other fields).

A stream is splitted in several fields which are organised in a tree. So all
fields have a parent, except of the root. Small example which will be used to
parse the string "\x03abc" (stream of previous paragraph):

>>> from field import FieldSet, Integer, String
>>> class MyFormat(FieldSet):
...     def createFields(self):
...             yield Integer(self, "length", "uint8", "String length")
...             yield String(self, "text", "string[%u]" % self["length"].value)
...

One goal in Hachoir is to make the write of a parser the more easy that it
could be. You just have to write one method, createFields, which will create
all fields.

Another goal is to create the less fields as possible. In most cases, no field
is created when a field set in instanciated. Fields are created when you access
them by their name. That's why, the special Python keyword ''yield'' is used
which permit to create only fields "on demand" (get more details about
FieldSet internals in later section).

Prototype of field classes are almost different, but the two first parameters
are always the same:
 * First one is the parent, of type FieldSet (is None for the root) ;
 * The second is the name of the field.

Ok, let's play with our new field set:

>>> format = MyFormat(None, "myformat", stream)
>>> format.size               # get size in bits
32
>>> format["text"].value
'abc'
>>> "length" in format        # test if the field 'length' does exist
True
>>> # Easiest way to display a field set content
>>> for field in format:
...     print "%s=%s" % (field.name, field.display)
...
length=3
text="abc"

Details about Field class
-------------------------

A field contains a lot of informations, attributes are:
 * name: Field name, unique in his parent field set and can't be changed. It
   is used as key to access to the field from the field set ;
 * size: Size in bits, can't be changed ;
 * address: Address in bits, relative to parent address, can't be changed ;
 * absolute_address: Address in bits from the beginning of the stream ;
 * parent: Parent of the field (is None for root field set) ;
 * root: Root of all field sets ;
 * value: Formatted value (integer, string, boolean, ...) value of the field.
   Don't use this argument with print function, better use display attribute ;
 * display: A string representing field value, has limited size ;
 * path: Full "path" of the field from the root (eg. "/png/header/content") ;
 * is_field_set: If the value is True, the field contains other fields, it's
   a field set.

Examples:
>>> field = format["text"]
>>> field.name
'text'
>>> field.path
'/myformat/text'
>>> field.value
'abc'
>>> field.size
24
>>> field.address
8

Some Hachoir internals
======================

When a field is really created?
-------------------------------

A field is created when someone ask to access it, or when another field is
asked and the field is before it. So if you use a field in your field set
constructor, one or more fields will be created.

Example:
>>> from field import FieldSet, Integer, String
>>> class Point(FieldSet):
...     def __init__(self, parent, name, stream, description="Point"):
...         FieldSet.__init__(self, parent, name, stream, description)
...         if self["color"].value == -1:
...             self.description += " (no color)"
...
...     def createFields(self):
...         yield Integer(self, "color", "int8", "Point color (-1 for none)")
...         yield Integer(self, "use_3d", "int8", "Does it use Z axis?")
...         yield Integer(self, "x", "int8", "X axis value")
...         yield Integer(self, "y", "int8", "Y axis value")
...         if self["use_3d"] == 1:
...             yield Integer(self, "z", "int8", "Z axis value")
...

In the constructor, the field "color" is asked. So the field list will
contains one field (color):
>>> stream = FileStream(StringIO("\x2A\x00\x04\x05"), None)
>>> p = Point(None, "point", stream)
>>> len(p.fields)
1

WARNING: Only access 'fields' attribute if you know what you are doing.

If you access another field, the field list will grow up until the requested
field is reached:
>>> x = p["x"].value
>>> len(p.fields)
3

Some field set methods which create new fields:
 * __getitem__(): feed field list until requested field is reached
   (or raise MissingField exception) ;
 * __len__(): create all fields ;
 * __iter__(): begin to iterate in existing fields, and the iterate in new
   fields until all fields are created ;
 * __contains__(): feed field list until requested field is reached, may
   create all fields if the field is missing.

The size attribute also interact with field list creation, but it's mechanism
is little bit more complex. By default, the whole field list have to be built
before size value can be read. But you can specify field list size:
 * if field list is fixed, use class attribute static_size ;
 * else you can set _size instance attribute in the constructor.

Two examples:
>>> class FourBytes(FieldSet):
...     static_size = 32
...     def createFields(self):
...         yield Integer(self, "four", "uint32")
...
>>> class DynamicSize(FieldSet):
...     def __init__(self, parent, name, stream, nb_items, description="Point"):
...         FieldSet.__init__(self, parent, name, stream, description)
...         self.nb_items = nb_items
...         self._size = nb_items * 32   # 32 is the size of one item
...
...     def createFields(self):
...         for index in range(self.nb_items):
...             yield Integer(self, "item[]", "uint32")
...

When the value of a field is read?
----------------------------------

When a field is created, the value of the field doesn't exist (equals to
None). The value is really read when you read the field value using '.value'
or '.display' field attributes. The value is then stored in the field.

Details about field name
------------------------

The name of a field have to be unique in a field set because it is used as
key in the field list. The argument 'name' of the Field constructor can be
changed in the the constructor, but should not (and can no) be changed after
that.

For arrays, you can use the 'magic' prefix « [] » (eg. "item[]") which will
be replaced by « [index] » where the number index is a counter starting a
zero.

Endian
------

The "endian" is the way in which ''bytes'' are stored. There are two important
orders:
 * « Big endian » in which _big_ numbers are written first (Intel x86 CPU)
 * « Little endian » in which _little_ numbers are written first (PowerPC CPU)

The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
little endian.

The endian is global to a FieldSet and is a class attribute. Two allowed
values are "<" (little endian) and ">" (big endian). Default value is the
international network order: "<", big endian.

Example to set endian:
>>> class UseLittleEndian(FieldSet):
...     endian = ">"
...     # (...)
...

Explore a field set using it's path
-----------------------------------

Fields are stored in a tree. To explore the tree you have differents tools:
 * attribute root of a field which go to tree root ;
 * attribute parent go to field parent (is None for tree root) ;
 * and you can specify a path in __getitem__() argument.

There are differents valid syntax of a path:
 * path to a child of current node: field["content"] ;
 * path to a child of the parent: field["../brother"] ;
 * path from the root: field["/header/key"].

Event handling
--------------

Code is not finished yet, so don't need documentation :-) See:
 * FieldSet.connect(event, handler)
 * FieldSet.raiseEvent(event,  arg1, arg2, ...)

Get more informations
=====================

Hachoir website:
   http://www.haypocalc.com/wiki/Hachoir

