Some Hachoir internals
======================

When a field is really created?
-------------------------------

A field is created when someone ask to access it, or when another field is
asked and the field is before it. So if you use a field in your field set
constructor, one or more fields will be created. Example:

>>> from field import FieldSet, Integer, String
>>> class Point(FieldSet):
...     def __init__(self, parent, name, stream, description="Point"):
...         FieldSet.__init__(self, parent, name, stream, description)
...         if self["color"].value == -1:
...             self.description += " (no color)"
...
...     def createFields(self):
...         yield Integer(self, "color", "int8", "Point color (-1 for none)")
...         yield Integer(self, "use_3d", "int8", "Does it use Z axis?")
...         yield Integer(self, "x", "int8", "X axis value")
...         yield Integer(self, "y", "int8", "Y axis value")
...         if self["use_3d"] == 1:
...             yield Integer(self, "z", "int8", "Z axis value")
...

In the constructor, the field "color" is asked. So the field list will
contains one field (color):

>>> from stream import StringInputStream
>>> stream = StringInputStream("\x2A\x00\x04\x05")
>>> p = Point(None, "point", stream)
>>> len(p.fields)
1

.. WARNING::
   Only access 'fields' attribute if you know what you are doing.

If you access another field, the field list will grow up until the requested
field is reached:

>>> x = p["x"].value
>>> len(p.fields)
3

Some field set methods which create new fields:
 * ``__getitem__()``: feed field list until requested field is reached
   (or raise MissingField exception) ;
 * ``__len__()``: create all fields ;
 * ``__iter__()``: begin to iterate in existing fields, and the iterate in new
   fields until all fields are created ;
 * ``__contains__()``: feed field list until requested field is reached, may
   create all fields if the field is missing.

The size attribute also interact with field list creation, but it's mechanism
is little bit more complex. By default, the whole field list have to be built
before size value can be read. But you can specify field list size:
* if field list is fixed, use class attribute static_size ;
* else you can set _size instance attribute in the constructor.

Two examples:

>>> class FourBytes(FieldSet):
...     static_size = 32
...     def createFields(self):
...         yield Integer(self, "four", "uint32")
...
>>> class DynamicSize(FieldSet):
...     def __init__(self, parent, name, stream, nb_items, description="Point"):
...         FieldSet.__init__(self, parent, name, stream, description)
...         self.nb_items = nb_items
...         self._size = nb_items * 32   # 32 is the size of one item
...
...     def createFields(self):
...         for index in range(self.nb_items):
...             yield Integer(self, "item[]", "uint32")
...

When the value of a field is read?
----------------------------------

When a field is created, the value of the field doesn't exist (equals to
None). The value is really read when you read the field value using '.value'
or '.display' field attributes. The value is then stored in the field.

Details about field name
------------------------

The name of a field have to be unique in a field set because it is used as
key in the field list. The argument 'name' of the Field constructor can be
changed in the the constructor, but should not (and can no) be changed after
that.

For arrays, you can use the 'magic' prefix « [] » (eg. "item[]") which will
be replaced by « [index] » where the number index is a counter starting a
zero.

Endian
------

The "endian" is the way in which ''bytes'' are stored. There are two important
orders:

* « Big endian » in which *big* numbers are written first (Intel x86 CPU) ;
* « Little endian » in which *little* numbers are written first (PowerPC CPU).

The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
little endian.

The endian is global to a FieldSet and is a class attribute. Two allowed
values are "<" (little endian) and ">" (big endian). Default value is the
international network order: "<", big endian.

Example to set endian:

>>> class UseLittleEndian(FieldSet):
...     endian = ">"
...

Explore a field set using it's path
-----------------------------------

Fields are stored in a tree. To explore the tree you have differents tools:
 * attribute *root* of a field which go to tree root ;
 * attribute *parent* go to field parent (is None for tree root) ;
 * and you can specify a path in *__getitem__()* argument.

There are differents valid syntax of a path:
 * path to a child of current node: ``field["content"]`` ;
 * path to a child of the parent: ``field["../brother"]`` ;
 * path from the root: ``field["/header/key"]``.

Event handling
--------------

Code is not finished yet, so don't need documentation :-) See:
 * ``FieldSet.connect(event, handler)`` ;
 * ``FieldSet.raiseEvent(event,  arg1, arg2, ...)``.

