Write your own format FieldSet class
====================================

Input stream
------------

For different reasons (eg. addresses with bit granularity), Hachoir uses it's
own stream classes: ``InputStream``. But don't use it directly, use
``FileInputStream`` function (needs a filename) or ``StringInputStream``
(needs a string). Here is a small example to create a stream:

>>> from stream import StringInputStream
>>> stream = StringInputStream("\x03abc")

Most interesting methods are:

>>> stream.size            # get size in bits
32
>>> stream.getBits(0, 8)   # get 8 bits at address 0
3
>>> stream.getBytes(8, 3)  # get 3 bytes at address 8
'abc'

Support your own format using FieldSet
--------------------------------------

In the Hachoir, everything is stored in a field. The parent of all classes is
the class Field, but it can't be used directly. They are four different types
of fields:
* Bits: number with a size in bits ;
* Integer: number with a size in bytes ;
* String: string of characters with a size in bytes ;
* FieldSet: a ordered list of fields (contains other fields).

A stream is splitted in several fields which are organised in a tree. So all
fields have a parent, except of the root. Small example which will be used to
parse the string "\x03abc" (stream of previous paragraph):

>>> from field import FieldSet, Integer, String
>>> class MyFormat(FieldSet):
...     def createFields(self):
...             yield Integer(self, "length", "uint8", "String length")
...             yield String(self, "text", "string[%u]" % self["length"].value)
...

One goal in Hachoir is to make the write of a parser the more easy that it
could be. You just have to write one method, createFields, which will create
all fields.

Another goal is to create the less fields as possible. In most cases, no field
is created when a field set in instanciated. Fields are created when you access
them by their name. That's why, the special Python keyword ''yield'' is used
which permit to create only fields "on demand" (get more details about
FieldSet internals in later section).

Prototype of field classes are almost different, but the two first parameters
are always the same:

* First one is the parent, of type FieldSet (is None for the root) ;
* The second is the name of the field.

Ok, let's play with our new field set:

>>> format = MyFormat(None, "myformat", stream)
>>> format.size               # get size in bits
32
>>> format["text"].value
'abc'
>>> "length" in format        # test if the field 'length' does exist
True
>>> # Easiest way to display a field set content
>>> for field in format:
...     print "%s=%s" % (field.name, field.display)
...
length=3
text="abc"

Details about Field class
-------------------------

A field contains a lot of informations, attributes are:
 * *name*: Field name, unique in his parent field set and can't be changed. It
   is used as key to access to the field from the field set ;
 * *size*: Size in bits, can't be changed ;
 * *address*: Address in bits, relative to parent address, can't be changed ;
 * *absolute_address*: Address in bits from the beginning of the stream ;
 * *parent*: Parent of the field (is None for root field set) ;
 * *root*: Root of all field sets ;
 * *value*: Formatted value (integer, string, boolean, ...) value of the field.
   Don't use this argument with print function, better use display attribute ;
 * *display*: A string representing field value, has limited size ;
 * *path*: Full "path" of the field from the root (eg. "/png/header/content") ;
 * *is_field_set*: If the value is True, the field contains other fields, it's
   a field set.

Examples:

>>> field = format["text"]
>>> field.name
'text'
>>> field.path
'/myformat/text'
>>> field.value
'abc'
>>> field.size
24
>>> field.address
8

